<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sonar Beam Pattern Analysis Tool</title>
    <!-- 
        We use Plotly.js from CDN for high-quality scientific plotting.
        CDN (Content Delivery Network) means we load the library from the internet
        instead of downloading and hosting it ourselves.
    -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        /* 
        CSS (Cascading Style Sheets) controls how our webpage looks.
        We define styles here that make our tool look professional and easy to use.
        */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f4f8;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
            padding: 20px;
            background: #f8fafc;
            border-radius: 8px;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        label {
            font-weight: bold;
            color: #2c3e50;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }
        
        select, .plot-toggle {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background: white;
            cursor: pointer;
        }
        
        .plot-toggle {
            background: #3498db;
            color: white;
            border: none;
            font-weight: bold;
        }
        
        .plot-toggle:hover {
            background: #2980b9;
        }
        
        .value-display {
            font-family: monospace;
            background: #e3f2fd;
            padding: 4px 8px;
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
        }
        
        .info-panel {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }
        
        .info-box {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .shading-viz {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
        }
        
        .theory-section {
            background: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-top: 25px;
            border-left: 4px solid #3498db;
        }
        
        .math-formula {
            background: #fff;
            padding: 10px;
            border-radius: 4px;
            font-family: monospace;
            text-align: center;
            margin: 10px 0;
            border: 1px solid #ddd;
        }
        
        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-radius: 6px;
            border: 1px solid #ffeaa7;
            margin: 15px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîä Interactive Sonar Beam Pattern Analysis Tool</h1>
        <p><em>Educational tool for understanding linear array acoustics and beam forming</em></p>
        
        <!-- 
        This info panel shows key calculated parameters.
        We use CSS Grid to create a responsive two-column layout.
        -->
        <div class="info-panel">
            <div class="info-box">
                <h3>üìä Array Parameters</h3>
                <div id="arrayInfo"></div>
            </div>
            <div class="info-box">
                <h3>üìê Beam Characteristics</h3>
                <div id="beamInfo"></div>
            </div>
        </div>
        
        <!-- 
        Controls section: This is where users interact with our simulation.
        We use CSS Grid with auto-fit to make it responsive on different screen sizes.
        -->
        <div class="controls">
            <div class="control-group">
                <label for="numElements">üî¢ Number of Elements (N):</label>
                <input type="range" id="numElements" min="4" max="32" value="16" step="1">
                <div class="value-display" id="numElementsValue">16</div>
                <small>More elements = narrower beam, more directional</small>
            </div>
            
            <div class="control-group">
                <label for="spacing">üìè Element Spacing (Œª):</label>
                <input type="range" id="spacing" min="0.3" max="1.0" value="0.5" step="0.05">
                <div class="value-display" id="spacingValue">0.5</div>
                <small>Œª = wavelength. 0.5Œª spacing prevents grating lobes</small>
            </div>
            
            <div class="control-group">
                <label for="frequency">‚ö° Frequency (kHz):</label>
                <input type="range" id="frequency" min="10" max="100" value="50" step="5">
                <div class="value-display" id="frequencyValue">50</div>
                <small>Higher frequency = shorter wavelength</small>
            </div>
            
            <div class="control-group">
                <label for="shadingType">üéØ Amplitude Shading:</label>
                <select id="shadingType">
                    <option value="uniform">Uniform (Unshaded)</option>
                    <option value="hamming">Hamming Window</option>
                    <option value="hanning">Hanning Window</option>
                    <option value="chebyshev">Chebyshev (30dB)</option>
                    <option value="kaiser">Kaiser (Œ≤=6)</option>
                    <option value="blackman">Blackman</option>
                </select>
                <small>Shading reduces side lobes but widens main lobe</small>
            </div>
            
            <div class="control-group">
                <label>üìà Plot Type:</label>
                <button class="plot-toggle" id="plotToggle" onclick="togglePlotType()">
                    Linear Plot
                </button>
                <small id="plotDescription">Angle vs dB (Cartesian coordinates)</small>
            </div>
        </div>
        
        <!-- Container for our main beam pattern plot -->
        <div id="beamPattern" style="width: 100%; height: 600px; margin: 20px 0;"></div>
        
        <!-- Container for showing the amplitude shading weights -->
        <div class="shading-viz">
            <h3>üìà Element Amplitude Weights</h3>
            <div id="shadingPattern" style="width: 100%; height: 300px;"></div>
        </div>
        
        <!-- Educational content explaining the theory -->
        <div class="theory-section">
            <h2>üìö Theory and Mathematics</h2>
            
            <div class="highlight">
                <h3>üéØ What is a Linear Array?</h3>
                <p>A linear array is a series of acoustic transducers (hydrophones or projectors) arranged in a straight line. 
                Each element contributes to the overall beam pattern, and by controlling their relative amplitudes and phases, 
                we can shape the directional response of the array.</p>
            </div>
            
            <h3>üìê Array Factor Formula</h3>
            <p>The beam pattern of a linear array is described by the <strong>Array Factor (AF)</strong>:</p>
            <div class="math-formula">
                AF(Œ∏) = Œ£(n=0 to N-1) w_n √ó e^(j√ón√ók√ód√ósin(Œ∏))
            </div>
            <p>Where:</p>
            <ul>
                <li><strong>w_n</strong> = amplitude weight for element n (this is what shading controls!)</li>
                <li><strong>k</strong> = 2œÄ/Œª (wave number)</li>
                <li><strong>d</strong> = element spacing</li>
                <li><strong>Œ∏</strong> = angle from array normal</li>
                <li><strong>N</strong> = number of elements</li>
            </ul>
            
            <h3>ü™ü Amplitude Shading (Windowing)</h3>
            <p>Amplitude shading applies different weights to array elements to control beam characteristics:</p>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 15px 0;">
                <div>
                    <h4>‚úÖ Benefits of Shading:</h4>
                    <ul>
                        <li>Reduces side lobe levels</li>
                        <li>Improves signal-to-interference ratio</li>
                        <li>Reduces false targets in sonar</li>
                        <li>Better angular resolution in cluttered environments</li>
                    </ul>
                </div>
                <div>
                    <h4>‚ö†Ô∏è Trade-offs:</h4>
                    <ul>
                        <li>Wider main lobe (reduced directivity)</li>
                        <li>Lower peak gain</li>
                        <li>Reduced array efficiency</li>
                        <li>More complex implementation</li>
                    </ul>
                </div>
            </div>
            
            <h3>üî¨ Common Shading Functions:</h3>
            <ul>
                <li><strong>Uniform:</strong> All elements weighted equally (w = 1). Maximum directivity, highest side lobes (~-13dB)</li>
                <li><strong>Hamming:</strong> w = 0.54 - 0.46√ócos(2œÄn/(N-1)). Side lobes ~-40dB</li>
                <li><strong>Hanning:</strong> w = 0.5√ó(1 - cos(2œÄn/(N-1))). Side lobes ~-32dB</li>
                <li><strong>Chebyshev:</strong> Optimized for equal side lobe levels at specified level</li>
                <li><strong>Kaiser:</strong> Flexible window with adjustable parameter Œ≤</li>
                <li><strong>Blackman:</strong> Very low side lobes (~-60dB) but wider main lobe</li>
            </ul>
        </div>
    </div>

    <script>
        /* 
        =================================================================
        JAVASCRIPT SECTION - This is where the magic happens!
        =================================================================
        */
        
        // Global variable to track current plot type
        let currentPlotType = 'linear'; // 'linear' or 'polar'
        
        /**
         * SECTION 1: SHADING FUNCTION DEFINITIONS
         * ======================================
         */
        
        function uniformShading(N) {
            return new Array(N).fill(1.0);
        }
        
        function hammingShading(N) {
            const weights = [];
            for (let n = 0; n < N; n++) {
                const weight = 0.54 - 0.46 * Math.cos(2 * Math.PI * n / (N - 1));
                weights.push(weight);
            }
            return weights;
        }
        
        function hanningShading(N) {
            const weights = [];
            for (let n = 0; n < N; n++) {
                const weight = 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
                weights.push(weight);
            }
            return weights;
        }
        
        function chebyshevShading(N, sidelobeLevel = 30) {
            const weights = [];
            const center = (N - 1) / 2;
            for (let n = 0; n < N; n++) {
                const x = (n - center) / center;
                const weight = Math.pow(Math.cos(Math.PI * x / 2), 2);
                weights.push(weight);
            }
            return weights;
        }
        
        function kaiserShading(N, beta = 6) {
            const weights = [];
            const center = (N - 1) / 2;
            for (let n = 0; n < N; n++) {
                const x = (n - center) / center;
                const weight = Math.exp(-beta * x * x);
                weights.push(weight);
            }
            return weights;
        }
        
        function blackmanShading(N) {
            const weights = [];
            for (let n = 0; n < N; n++) {
                const weight = 0.42 
                    - 0.5 * Math.cos(2 * Math.PI * n / (N - 1)) 
                    + 0.08 * Math.cos(4 * Math.PI * n / (N - 1));
                weights.push(weight);
            }
            return weights;
        }
        
        function getShadingWeights(type, N) {
            switch (type) {
                case 'uniform': return uniformShading(N);
                case 'hamming': return hammingShading(N);
                case 'hanning': return hanningShading(N);
                case 'chebyshev': return chebyshevShading(N, 30);
                case 'kaiser': return kaiserShading(N, 6);
                case 'blackman': return blackmanShading(N);
                default: return uniformShading(N);
            }
        }
        
        /**
         * SECTION 2: BEAM PATTERN CALCULATION
         * ==================================
         */
        
        function calculateBeamPattern(N, d_lambda, weights) {
            const angles = [];
            const pattern_dB = [];
            const pattern_linear = [];
            
            // Calculate pattern from -90¬∞ to +90¬∞ with 0.5¬∞ steps
            for (let theta_deg = -90; theta_deg <= 90; theta_deg += 0.5) {
                const theta_rad = theta_deg * Math.PI / 180;
                angles.push(theta_deg);
                
                // Calculate complex array factor
                let real_part = 0;
                let imag_part = 0;
                
                for (let n = 0; n < N; n++) {
                    const phase = 2 * Math.PI * d_lambda * n * Math.sin(theta_rad);
                    real_part += weights[n] * Math.cos(phase);
                    imag_part += weights[n] * Math.sin(phase);
                }
                
                // Calculate magnitude
                const pattern_value = Math.sqrt(real_part * real_part + imag_part * imag_part);
                pattern_linear.push(pattern_value);
            }
            
            // Convert to dB and normalize
            const maxValue = Math.max(...pattern_linear);
            for (let i = 0; i < pattern_linear.length; i++) {
                const dB_value = 20 * Math.log10(pattern_linear[i] / maxValue + 1e-10);
                pattern_dB.push(dB_value);
            }
            
            return { angles, pattern_dB, pattern_linear };
        }
        
        /**
         * SECTION 3: BEAM CHARACTERISTICS
         * ==============================
         */
        
        function calculateBeamwidth(angles, pattern_dB) {
            const maxIndex = pattern_dB.indexOf(Math.max(...pattern_dB));
            
            let leftIndex = maxIndex;
            let rightIndex = maxIndex;
            
            while (leftIndex > 0 && pattern_dB[leftIndex] > -3) leftIndex--;
            while (rightIndex < pattern_dB.length - 1 && pattern_dB[rightIndex] > -3) rightIndex++;
            
            return angles[rightIndex] - angles[leftIndex];
        }
        
        function findPeakSideLobeLevel(angles, pattern_dB) {
            let maxSideLobe = -Infinity;
            for (let i = 0; i < angles.length; i++) {
                if (Math.abs(angles[i]) > 20) { // Outside main lobe region
                    maxSideLobe = Math.max(maxSideLobe, pattern_dB[i]);
                }
            }
            return maxSideLobe;
        }
        
        /**
         * SECTION 4: PLOTTING FUNCTIONS
         * =============================
         */
        
        function togglePlotType() {
            currentPlotType = currentPlotType === 'linear' ? 'polar' : 'linear';
            const button = document.getElementById('plotToggle');
            const description = document.getElementById('plotDescription');
            
            if (currentPlotType === 'linear') {
                button.textContent = 'Linear Plot';
                description.textContent = 'Angle vs dB (Cartesian coordinates)';
            } else {
                button.textContent = 'Polar Plot';
                description.textContent = 'Conventional angular plot (Polar coordinates)';
            }
            
            updateBeamPatternPlot();
        }
        
        function updateBeamPatternPlot() {
            const N = parseInt(document.getElementById('numElements').value);
            const d_lambda = parseFloat(document.getElementById('spacing').value);
            const freq = parseInt(document.getElementById('frequency').value);
            const shadingType = document.getElementById('shadingType').value;
            
            const weights = getShadingWeights(shadingType, N);
            const { angles, pattern_dB } = calculateBeamPattern(N, d_lambda, weights);
            
            if (currentPlotType === 'linear') {
                plotLinearPattern(angles, pattern_dB, shadingType);
            } else {
                plotPolarPattern(angles, pattern_dB, shadingType);
            }
            
            // Calculate and update info displays
            const beamwidth = calculateBeamwidth(angles, pattern_dB);
            const sideLobeLevel = findPeakSideLobeLevel(angles, pattern_dB);
            updateInfoDisplays(N, d_lambda, freq, shadingType, beamwidth, sideLobeLevel, weights);
            updateShadingPlot(weights, shadingType);
        }
        
        function plotLinearPattern(angles, pattern_dB, shadingType) {
            const beamTrace = {
                x: angles,
                y: pattern_dB,
                type: 'scatter',
                mode: 'lines',
                name: `${shadingType.charAt(0).toUpperCase() + shadingType.slice(1)} Shading`,
                line: { color: '#2196F3', width: 3 },
                hovertemplate: 'Angle: %{x}¬∞<br>Response: %{y:.1f} dB<extra></extra>'
            };
            
            const ref3dB = {
                x: [-90, 90],
                y: [-3, -3],
                type: 'scatter',
                mode: 'lines',
                name: '-3dB Line',
                line: { color: '#ff4444', width: 2, dash: 'dash' },
                hovertemplate: '-3dB Reference<extra></extra>'
            };
            
            const layout = {
                title: `üîä Linear Array Beam Pattern - ${shadingType} (Linear Plot)`,
                xaxis: {
                    title: 'Angle from Array Normal (degrees)',
                    range: [-90, 90],
                    gridcolor: '#e0e0e0',
                    tickmode: 'linear',
                    dtick: 15
                },
                yaxis: {
                    title: 'Relative Response (dB)',
                    range: [-50, 5],
                    gridcolor: '#e0e0e0'
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: 'white',
                margin: { l: 70, r: 30, t: 80, b: 60 }
            };
            
            Plotly.newPlot('beamPattern', [beamTrace, ref3dB], layout, {responsive: true});
        }
        
        function plotPolarPattern(angles, pattern_dB, shadingType) {
            // Convert dB to linear for polar plot (with floor for visibility)
            const pattern_linear = pattern_dB.map(dB => Math.pow(10, Math.max(dB, -40) / 20));
            
            const polarTrace = {
                type: 'scatterpolar',
                mode: 'lines',
                r: pattern_linear,
                theta: angles,
                name: `${shadingType.charAt(0).toUpperCase() + shadingType.slice(1)} Shading`,
                line: { color: '#2196F3', width: 3 },
                hovertemplate: 'Angle: %{theta}¬∞<br>Response: %{customdata:.1f} dB<extra></extra>',
                customdata: pattern_dB
            };
            
            const layout = {
                title: `üîä Linear Array Beam Pattern - ${shadingType} (Polar Plot)`,
                polar: {
                    radialaxis: {
                        visible: true,
                        range: [0, 1],
                        tickmode: 'array',
                        tickvals: [0.1, 0.32, 0.56, 0.71, 1.0],
                        ticktext: ['-20dB', '-10dB', '-5dB', '-3dB', '0dB'],
                        gridcolor: '#e0e0e0'
                    },
                    angularaxis: {
                        tickmode: 'linear',
                        dtick: 30,
                        direction: 'clockwise',
                        rotation: 90,
                        gridcolor: '#e0e0e0'
                    },
                    bgcolor: '#fafafa'
                },
                paper_bgcolor: 'white',
                margin: { l: 50, r: 50, t: 80, b: 50 }
            };
            
            Plotly.newPlot('beamPattern', [polarTrace], layout, {responsive: true});
        }
        
        function updateShadingPlot(weights, shadingType) {
            const elementIndices = weights.map((_, i) => i);
            
            const shadingTrace = {
                x: elementIndices,
                y: weights,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'Amplitude Weights',
                line: { color: '#9c27b0', width: 3 },
                marker: { size: 8, color: '#9c27b0' },
                hovertemplate: 'Element: %{x}<br>Weight: %{y:.3f}<extra></extra>'
            };
            
            const layout = {
                title: `üìà ${shadingType.charAt(0).toUpperCase() + shadingType.slice(1)} Amplitude Weights`,
                xaxis: { title: 'Element Index', gridcolor: '#e0e0e0' },
                yaxis: { 
                    title: 'Amplitude Weight', 
                    gridcolor: '#e0e0e0',
                    range: [0, Math.max(...weights) * 1.1]
                },
                plot_bgcolor: '#fafafa',
                paper_bgcolor: 'white',
                margin: { l: 60, r: 30, t: 60, b: 60 }
            };
            
            Plotly.newPlot('shadingPattern', [shadingTrace], layout, {responsive: true});
        }
        
        function updateInfoDisplays(N, d_lambda, freq, shadingType, beamwidth, sideLobeLevel, weights) {
            // Update control displays
            document.getElementById('numElementsValue').textContent = N;
            document.getElementById('spacingValue').textContent = d_lambda.toFixed(2);
            document.getElementById('frequencyValue').textContent = freq;
            
            // Calculate parameters
            const arrayLength = (N - 1) * d_lambda;
            const wavelength_m = 1500 / (freq * 1000); // Assuming sound speed = 1500 m/s
            const physicalLength = arrayLength * wavelength_m;
            
            // Array info
            document.getElementById('arrayInfo').innerHTML = `
                <strong>Array Length:</strong> ${arrayLength.toFixed(2)}Œª<br>
                <strong>Physical Length:</strong> ${physicalLength.toFixed(2)}m<br>
                <strong>Frequency:</strong> ${freq} kHz<br>
                <strong>Wavelength:</strong> ${wavelength_m.toFixed(3)}m<br>
                <strong>Elements:</strong> ${N}
            `;
            
            // Beam characteristics
            document.getElementById('beamInfo').innerHTML = `
                <strong>-3dB Beamwidth:</strong> ${beamwidth.toFixed(1)}¬∞<br>
                <strong>Peak Side Lobe:</strong> ${sideLobeLevel.toFixed(1)} dB<br>
                <strong>Shading:</strong> ${shadingType}<br>
                <strong>Directivity Index:</strong> ${(10 * Math.log10(arrayLength * 2)).toFixed(1)} dB<br>
                <strong>Array Efficiency:</strong> ${(100 * weights.reduce((sum, w) => sum + w*w, 0) / (N * Math.max(...weights)**2)).toFixed(1)}%
            `;
        }
        
        /**
         * SECTION 5: EVENT LISTENERS AND INITIALIZATION
         * ============================================
         */
        
        // Add event listeners to all controls
        document.getElementById('numElements').addEventListener('input', updateBeamPatternPlot);
        document.getElementById('spacing').addEventListener('input', updateBeamPatternPlot);
        document.getElementById('frequency').addEventListener('input', updateBeamPatternPlot);
        document.getElementById('shadingType').addEventListener('change', updateBeamPatternPlot);
        
        // Initialize the plot when page loads
        window.addEventListener('load', function() {
            updateBeamPatternPlot();
        });
        
    </script>
</body>
</html>
